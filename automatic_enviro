import re
import os
from datetime import datetime

def remove_comments(sql_script):
    """
    Remove SQL comments from the script.
    """
    # Remove single-line comments (--)
    sql_script = re.sub(r'--.*', '', sql_script)
    # Remove multi-line comments (/* ... */)
    sql_script = re.sub(r'/\*.*?\*/', '', sql_script, flags=re.DOTALL)
    
    return sql_script

def extract_tables(sql_script):
    """
    Extract table names and identify volatile tables from the SQL script using regex.
    """
    sql_script = remove_comments(sql_script)  # Remove comments before extracting tables

    # Updated regex patterns to capture database and table names in the format database.table
    create_table_pattern = re.compile(r'CREATE\s+(MULTISET\s+)?(VOLATILE\s+)?TABLE\s+(\w+\.\w+)\s+AS', re.IGNORECASE)
    other_table_pattern = re.compile(r'(INSERT\s+INTO|MERGE\s+INTO|JOIN|FROM|UPDATE)\s+(\w+\.\w+)', re.IGNORECASE)

    all_tables = set()
    volatile_tables = set()

    # Find tables created with CREATE TABLE statement
    create_matches = create_table_pattern.findall(sql_script)
    for match in create_matches:
        if len(match) >= 3:
            table_name = match[2]
            all_tables.add(table_name)
            if match[1] and 'VOLATILE' in match[1].strip().upper():
                volatile_tables.add(table_name)

    # Find tables mentioned with other SQL keywords
    other_matches = other_table_pattern.findall(sql_script)
    for match in other_matches:
        if len(match) >= 2:
            table_name = match[1]
            if table_name not in volatile_tables:
                all_tables.add(table_name)

    # Keep only valid tablename.databasename format
    all_tables = {table for table in all_tables if '.' in table}
    volatile_tables = {table for table in volatile_tables if '.' in table}

    return list(all_tables), list(volatile_tables)

def generate_statements(tables, with_data=True):
    """
    Generate SQL statements to create test tables using Teradata SQL syntax.
    """
    statements = []
    table_mapping = {}
    current_date = datetime.now().strftime('%d_%m_%Y')
    unique_tables = set(tables)  # Ensure unique table names

    for table in unique_tables:
        database_name, table_name = table.split('.')
        test_table_name = f"{table_name}_test"
        table_mapping[table] = f"{database_name}.{test_table_name}"
        if with_data:
            statement = f"CREATE TABLE {database_name}.{test_table_name} AS {table} WITH DATA;"
        else:
            statement = f"CREATE TABLE {database_name}.{test_table_name} AS {table} WITH NO DATA;"
        statements.append(statement)
    
    return statements, table_mapping

def create_test_tables(sql_script, with_data=True):
    """
    Automate the process of creating test tables.
    """
    # Extract table names and volatile tables from the SQL script
    all_tables, volatile_tables = extract_tables(sql_script)
    
    # Identify non-volatile tables
    non_volatile_tables = [table for table in all_tables if table not in volatile_tables]
    
    # Generate SQL statements for test tables
    test_statements, table_mapping = generate_statements(non_volatile_tables, with_data)
    
    return test_statements, table_mapping

def replace_tables(sql_script, table_mapping, tables_to_keep):
    """
    Replace original table names with test table names in the SQL script.
    """
    for original_table, test_table in table_mapping.items():
        if original_table not in tables_to_keep:
            sql_script = re.sub(rf'\b{re.escape(original_table)}\b', test_table, sql_script)
    return sql_script

def process_files(directory_path, with_data=True, table_name_filter=None, single_output=False, specific_file=None, tables_to_keep=None):
    """
    Process SQL files in the given directory. Optionally process only a specific file.
    """
    all_statements = []

    # Initialize tables_to_keep if not provided
    if tables_to_keep is None:
        tables_to_keep = set()

    # Determine the files to process
    files_to_process = []
    if specific_file:
        # Add .sql extension if not provided
        if not specific_file.endswith('.sql'):
            specific_file += '.sql'
        files_to_process = [specific_file]
    else:
        files_to_process = [f for f in os.listdir(directory_path) if f.endswith(".sql")]

    for filename in files_to_process:
        input_file_path = os.path.join(directory_path, filename)
        
        # Read the SQL script from the input file
        with open(input_file_path, 'r') as file:
            sql_script = file.read()
        
        # Check if the SQL script contains the specified table name (if provided)
        if table_name_filter and not re.search(rf'\b{table_name_filter}\b', sql_script, re.IGNORECASE):
            continue

        test_statements, table_mapping = create_test_tables(sql_script, with_data)
        
        current_date = datetime.now().strftime('%d_%m_%Y')

        # Write test table creation statements
        if single_output:
            all_statements.extend(test_statements)
        else:
            output_file_path = os.path.join(directory_path, f"test_{filename}_{current_date}.sql")
            with open(output_file_path, 'w') as file:
                for statement in test_statements:
                    file.write(statement + '\n')
            print(f"Processed {filename} and saved test table SQL statements to test_{filename}_{current_date}.sql")
        
        # Create test script by replacing table names
        modified_sql_script = replace_tables(sql_script, table_mapping, tables_to_keep)
        modified_file_path = os.path.join(directory_path, f"{filename}_test_{current_date}.sql")
        with open(modified_file_path, 'w') as file:
            file.write(modified_sql_script)
        print(f"Processed {filename} and saved modified SQL script to {filename}_test_{current_date}.sql")

    if single_output and all_statements:
        # Remove duplicate statements by using a set
        unique_statements = set(all_statements)
        current_date = datetime.now().strftime('%d_%m_%Y')
        output_file_path = os.path.join(directory_path, f"test_tables_{current_date}.sql")
        with open(output_file_path, 'w') as file:
            for statement in unique_statements:
                file.write(statement + '\n')
        print(f"All test table SQL statements have been saved to {output_file_path}")

if __name__ == "__main__":
    # Path to the directory containing SQL files
    directory_path = r"C:\Users\asus\OneDrive\Desktop\sql_scripts"

    # Ask the user if they want the tables with data or without data
    with_data_input = input("Do you want to create the tables with data? (yes/no): ").strip().lower()
    with_data = with_data_input in ['yes', 'y']

    # Ask the user if they want to filter by a specific table name
    table_name_input = input("Enter a table name to filter the SQL scripts (leave blank to process all scripts): ").strip()
    table_name_filter = table_name_input if table_name_input else None

    # Ask the user if they want to process a specific file
    specific_file_input = input("Do you want to process a specific file? Enter the filename (with or without .sql extension) or leave blank to process all files: ").strip()
    specific_file = specific_file_input if specific_file_input else None

    # Ask the user if they want to output to a single file or separate files
    single_output_input = input("Do you want to output all statements to a single file? (yes/no): ").strip().lower()
    single_output = single_output_input in ['yes', 'y']

    # Ask the user if there are any tables they want to keep unchanged
    tables_to_keep_input = input("Enter the table names to keep unchanged, separated by commas (e.g., database1.table1,database2.table2): ").strip()
    tables_to_keep = set(tables_to_keep_input.split(',')) if tables_to_keep_input else set()

    # Process the SQL files
    process_files(directory_path, with_data, table_name_filter, single_output, specific_file, tables_to_keep)

